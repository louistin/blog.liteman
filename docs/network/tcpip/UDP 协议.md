# UDP 协议

## UDP 协议基础

* UDP 协议报文首部

    ```bash
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Source Port          |       Destination Port        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Lenght            |           Checksum            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             data                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    Length : 包括首部的全长, 最小为 8 bit
    UDP 与 TCP 端口相互独立
    ```

* UDP 报文

    ```bash
    报文长度影响因素
        UDP 协议限制.
            最大长度 2^16(Length) - 1 - 8(UDP Header) - 20(IP Header)
        以太网数据帧长度, 数据链路层 MTU
        Socket UDP 发送缓冲区大小

    UDP 数据包理想长度
        确保数据包在下层协议中不要被切割
        数据链路层以太网帧大小 [64, 1518] byte, 除去帧头后, MTU = 1500 byte
        局域网下建议 UDP 最大大小 = 1500 - 20(IP Header) - 8(UDP Header) = 1472
        Internet 标准 MTU = 576 byte
        Internet 编程建议 UDP 最大大小 = 576 - 20 - 8 = 548 byte

    UDP 报文长度可以为0
    一个 UDP 数据报对应组装一份 IP 数据报
    ```

* UDP 数据包发送与接收

    ```bash
    UDP 数据包有界性
        阻塞模式下, UDP 以数据包作为界限, 客户端发送次数 = 服务端接收次数
    UDP 数据包无序性和不可靠性

    UDP 数据包在传输中, 由于 MTU 限制, 可能会出现分片传输, UDP 分片与组片问题由 IP 层处理,
      提交到传输层的一定是一个完整的 UDP 包(传输层 buffer 足够大时), 如果某个 IP 分片丢失,
      UDP 中 CRC 检验不通过, 则会丢弃数据, 也不会通知是否接收成功.
    ```

    - IP 分片

    ```bash
    IP 分片可以是在源发送端主机, 也可以是在中间路由器上.
    IP 数据报分片后在到达目的地后进行重新组装(非最终目的地, 可以是中间路由器).
    分片过程中, IP Header 中有一个标识字段标识 more fragments, 除最后一片外, 其他每片都
      将该比特标志字段置为 1. 标志字段中有一个比特为 Dont fragments, 置为 1 则 IP 将不
      对数据报进行分片.
    IP 分片后, 每一个分片都成为一个分组, 具有自己的 IP Header.
    任何一片数据丢失, 都需要重传整个数据报, 这依赖于传输层协议机制. 中间路由器会执行未知的分片
      操作, 所以要尽量避免分片.
    分片后, 传输层首部只会出现在第一片数据中.
    IP 数据报是指 IP 层端到端的传输单元(在分片前和重新组装之后)
    分组是指在 IP 层和链路层之间传送的数据单元, 一个分组可以是一个完整的 IP 数据报, 也可以是
      IP 数据报的一个分片

    当 UDP 数据报数据部分长度 >1472 时, 就会分片.
    ```

    ```bash
    IP 从上层接收到数据后, 要根据 IP 地址来判断从哪个接口发送数据, 并进行 MTU 查询, 如果数
      据大小超过 MTU 则进行数据分片. 数据的分片对上层和下层透明.

    在 IP 头中, 16bit 识别号唯一记录了一个 IP 包的 ID, 具有同一个 ID 的 IP 分片将会被重
      新组装, 13位片位移则记录了某 IP 片相对整个包的位置, 片位移前的 3bit 标志则标识该分片
      后是否还有新的分片. 这三个标识组成了 IP 分片的所有信息, 接收方可以根据这些信息对 IP
      数据进行重新组织.

    ```

* UDP 丢包

    ```bash
    IP 层分片丢失, CRC 检验包不完整
    UDP Socket 缓冲区满
        `cat /proc/sys/net/core/rmem_default cat /proc/sys/net/core/rmem_max`
          查看系统 Socket 缓冲默认值与最大值. 在服务器未过载时可以通过加大缓冲区缓解丢包
    UDP Socket 缓冲区过小
    ARP 缓存过期
        ARP 缓存时间为 10min, ARP 缓存列表没有目的端 MAC 或缓存过期, 户发送 ARP 请求获
          取 MAC 地址, 在没有获取到之前, 内核会默认缓存 3 个 UDP 包到 arp_queue 中,
          多余的包会丢弃. 可以修改 /proc/sys/net/ipv4/neigh/unres_qlen 增加缓存

    丢包信息查看
        cat /proc/net/udp
            drops 丢包信息
            inode Soket 全局唯一虚拟节点号
                lsof -P -n | grep inode 查看具体进程
    ```

* UDP TCP 探讨

    ```bash
    理论上 UDP 无连接, 无需重传确认, 应该比 TCP 高效, 但实际不一定.
    影响 UDP 高效的因素:
        UDP 不受 MTU 影响, UDP 发送大量小包, 或超大包而又有分片丢失时, 以及网络状况动态变
          化时, 都可以导致网络有效吞吐率低
        无法动态调整发包
            UDP 没有确认机制, 没有流量控制和拥塞控制, 不能调整发包速率, 导致丢包. 丢包时,
              不合理的简单重传策略也会导致重传风暴, 进一步恶化网络环境
        UDP 改进成本较高
            用户添加简单重传和动态发包大小优化
    ```

* UDP 适用场景

    ```bash
    高通信实时性要求和低持续性要求
        短连接通信
            只需要发几个包, 并且对丢包容忍度好
            DNS 查询
        高实时性
            NTP 协议
    多点通信场景
        NAT 穿透
        多人实时音视频
    ```

## FAQ
1. 数据包长度超过 2^16 - 1 - 8 - 20 = 65507 字节会怎样?

    `cat /proc/sys/net/core/wmem_default` UDP 发送缓冲区大于此值时, `send`/`sendto`
      函数报错误码 1(Operation not permitted, Message too long); 发送缓冲区小于此值
      时, `send`/`sendto`  函数报错误码 1(Operation not permitted, No buffer
      space available)

2. 客户端先后发送 300 500 字节数据, 在服务端三次阻塞调用 recvfrom(300), 存在哪些可能?

    a. 由于存在有界性, 可能第一次收到 300 字节, 第二次收到 500 字节, 但是用户空间 buffer
        不够, 丢掉 200 字节, 第三次没数据阻塞<br>
    b. 由于存在无序性, 有可能 a 中的第一次和第二次收到的流程相反<br>
    c. 由于不可靠性, 可能中间某次丢包导致一直阻塞到超时<br>

3. UDP 冗余传输方案

    假如传输 1 2 3 4 5 6 UPD 数据包. 实际传输中按照 1 12 23 34 45 56 6 这样传输.<br>
    优点降低丢包率, 缺点是加重网络负载, 有可能丢包更多了...