# UDP 协议

## UDP 协议基础

* UDP 协议报文首部

    ```bash
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Source Port          |       Destination Port        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |             Lenght            |           Checksum            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                             data                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ```

* UDP 报文

    ```bash
    报文长度影响因素
        UDP 协议限制.
            最大长度 2^16(Length) - 1 - 8(UDP Header) - 20(IP Header)
        以太网数据帧长度, 数据链路层 MTU
        Socket UDP 发送缓冲区大小

    UDP 数据包理想长度
        确保数据包在下层协议中不要被切割
        数据链路层以太网帧大小 [64, 1518] byte, 除去帧头后, MTU = 1500 byte
        局域网下建议 UDP 最大大小 = 1500 - 20(IP Header) - 8(UDP Header) = 1472
        Internet 标准 MTU = 576 byte
        Internet 编程建议 UDP 最大大小 = 576 - 20 - 8 = 548 byte
    ```

* UDP 数据包发送与接收

    ```bash
    UDP 数据包有界性
        阻塞模式下, UDP 以数据包作为界限, 客户端发送次数 = 服务端接收次数
    UDP 数据包无序性和不可靠性

    UDP 数据包在传输中, 由于 MTU 限制, 可能会出现分片传输, UDP 分片与组片问题由 IP 层处理,
      提交到传输层的一定是一个完整的 UDP 包(传输层 buffer 足够大时), 如果某个 IP 分片丢失,
      UDP 中 CRC 检验不通过, 则会丢弃数据, 也不会通知是否接收成功.
    ```

* UDP 丢包

    ```bash
    IP 层分片丢失, CRC 检验包不完整
    UDP Socket 缓冲区满
        `cat /proc/sys/net/core/rmem_default cat /proc/sys/net/core/rmem_max`
          查看系统 Socket 缓冲默认值与最大值. 在服务器未过载时可以通过加大缓冲区缓解丢包
    UDP Socket 缓冲区过小
    ARP 缓存过期
        ARP 缓存时间为 10min, ARP 缓存列表没有目的端 MAC 或缓存过期, 户发送 ARP 请求获
          取 MAC 地址, 在没有获取到之前, 内核会默认缓存 3 个 UDP 包到 arp_queue 中,
          多余的包会丢弃. 可以修改 /proc/sys/net/ipv4/neigh/unres_qlen 增加缓存

    丢包信息查看
        cat /proc/net/udp
            drops 丢包信息
            inode Soket 全局唯一虚拟节点号
                lsof -P -n | grep inode 查看具体进程
    ```

* UDP TCP 探讨

    ```bash
    理论上 UDP 无连接, 无需重传确认, 应该比 TCP 高效, 但实际不一定.
    影响 UDP 高效的因素:
        UDP 不受 MTU 影响, UDP 发送大量小包, 或超大包而又有分片丢失时, 以及网络状况动态变
          化时, 都可以导致网络有效吞吐率低
        无法动态调整发包
            UDP 没有确认机制, 没有流量控制和拥塞控制, 不能调整发包速率, 导致丢包. 丢包时,
              不合理的简单重传策略也会导致重传风暴, 进一步恶化网络环境
        UDP 改进成本较高
            用户添加简单重传和动态发包大小优化
    ```

* UDP 适用场景

    ```bash
    高通信实时性要求和低持续性要求
        短连接通信
            只需要发几个包, 并且对丢包容忍度好
            DNS 查询
        高实时性
            NTP 协议
    多点通信场景
        NAT 穿透
        多人实时音视频
    ```

## FAQ
1. 数据包长度超过 2^16 - 1 - 8 - 20 = 65507 字节会怎样?
    `cat /proc/sys/net/core/wmem_default` UDP 发送缓冲区大于此值时, `send`/`sendto`
      函数报错误码 1(Operation not permitted, Message too long); 发送缓冲区小于此值
      时, `send`/`sendto`  函数报错误码 1(Operation not permitted, No buffer
      space available)

2. 客户端先后发送 300 500 字节数据, 在服务端三次阻塞调用 recvfrom(300), 存在哪些可能?
    a. 由于存在有界性, 可能第一次收到 300 字节, 第二次收到 500 字节, 但是用户空间 buffer
        不够, 丢掉 200 字节, 第三次没数据阻塞
    b. 由于存在无序性, 有可能 a 中的第一次和第二次收到的流程相反
    c. 由于不可靠性, 可能中间某次丢包导致一直阻塞到超时

3. UDP 冗余传输方案
    假如传输 1 2 3 4 5 6 UPD 数据包. 实际传输中按照 1 12 23 34 45 56 6 这样传输
    优点降低丢包率, 缺点是加重网络负载, 有可能丢包更多了...